######### ChIPpeakAnno ##########
https://www.bioconductor.org/packages/devel/bioc/vignettes/ChIPpeakAnno/inst/doc/ChIPpeakAnno.html
BiocManager::install("ChIPpeakAnno")

#Preparation for annotation
explainantion : https://www.bioconductor.org/packages/devel/bioc/vignettes/ChIPpeakAnno/inst/doc/ChIPpeakAnno.html 
# Chapter5 Bioconductor supported TxDb and EnsDb
##### Allow to have ALLLLLLLLL annotation types !!!
library(AnnotationHub)
ah <- AnnotationHub()

  # Obtain EnsDb:
  EnsDb_Mmusculus_all <- query(ah, pattern = c("Mus musculus", "EnsDb"))
  head(EnsDb_Mmusculus_all, n = 10)
  AH53222 | Ensembl 87 EnsDb for Mus Musculus
  AH53726 | Ensembl 88 EnsDb for Mus Musculus
  
  EnsDb_Mmusculus_88 <- EnsDb_Mmusculus_all[["AH53726"]] 

  # Obtain TxDb
  TxDb_Mmusculus_all <- query(ah, pattern = c("Mus musculus", "TxDb"))
  head(TxDb_Mmusculus_all, n = 10)
  AH52263 | TxDb.Mmusculus.UCSC.mm10.ensGene.sqlite  
  AH52264 | TxDb.Mmusculus.UCSC.mm10.knownGene.sqlite
  
  TxDb.Mmusculus_mm10 <- EnsDb_Mmusculus_all[["AH52264"]] 


###### Direct instalation of the libarary
    #BiocManager::install("EnsDb.Mmusculus.v79")
    #BiocManager::install('EnsDb.Hsapiens.v86')
    #BiocManager::install("TxDb.Mmusculus.UCSC.mm10.knownGene")
    #BiocManager::install("TxDb.Hsapiens.UCSC.hg38.knownGene")
library(EnsDb.Mmusculus.v79)    
library(EnsDb.Hsapiens.v86) 
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)   
    
library(tidyverse)
library(org.Hs.eg.db)
library(AnnotationDbi)

    
    
    
edb <- EnsDb.Hsapiens.v86
View(edb) 
# extract the features you want and convert to GRanges object
transcripts()
genes()
EnsDb2GR(ranges, feature)# convert the entire table to GRanges object!!


g_edb <- genes(edb)
head(g_edb) # Now I have ENSG0000XXX label and other labeling as corresponding colomns
g_edb

## To convert from NCBI
library(GenomeInfoDb)
# Convert peaks from UCSC to NCBI to match EnsDb
seqlevelsStyle(ctrl_gr5) <- "NCBI"
NCBI style: "1", "2", ..., "X", "Y"
UCSC style: "chr1", "chr2", ..., "chrX", "chrY"



#Allow direct conversion from MACS peak to GRanges
#GRanges is a GFF/bed/GTF format of object in R ! easy !!!
  
  # Convert peaks to GRanges
  The ChIPpeakAnno package provides an example peak file in narrowPeak format, which is generated by MACS. 
library(ChIPpeakAnno)

#Test EXEMPLE USING 1 FILE
# Same sample used as Deeptools
macs_peak <- "/Users/administrateur/Desktop/Bio_info/Neuroblastoma/4_GSE216291/macs2_broad/H3K27ac_SRR22002112_GSM6666073_IMR32_control_rep1_ChIP-Seq_Homo_sapiens_ChIP-Seq_sorted_filtered.bam_peaks.xls"

macs_peak_gr <- toGRanges(macs_peak, format = "MACS2.broad")  # format = c("BED", "GFF", "GTF", "MACS", "MACS2", "MACS2.broad", "narrowPeak", "broadPeak", "CSV", "others")
head(macs_peak_gr)



### Annotation (annotating macs_peak_gr object using the g-edb)
macs_peak_ensembl1 <- annotatePeakInBatch(macs_peak_gr1, 
                                          AnnotationData = g_edb )
head(macs_peak_ensembl1, n = 2)

### Add gene symbols
macs_peak_ensembl1$symbol <-  mapIds(org.Hs.eg.db::org.Hs.eg.db, 
                                     keys = macs_peak_ensembl1$feature, #source column
                                     keytype = "ENSEMBL", # old type of gene_ID
                                     column = "SYMBOL", # new type of gene_ID you want
                                     multiVals = "first") %>% make.names(unique = T)


macs_peak_ensembl1$feature # Give back the ENSG
head(macs_peak_ensembl, n = 2)


##  Handle replicates
4.1 Obtain final peak set from replicates

For experiments with two or more biological replicates, there are several strategies22 https://ro-che.info/articles/2018-07-11-chip-seq-consensus to retrieve a final peak set:
  
  #Take the intersection of peaks:
  Most conservative, reduces noise by considering the most robust and consistently enriched peaks
May result in small number of peaks with narrower widths
# Take the union of all peaks: 
may lead to large number of peaks
Least conservative, provides a more comprehensive view of the binding landscape
Useful for identifying condition-specific or rare binding events
# Merge the overlapping peaks: 
may lead to peaks with broader widths
Can be achieved with ChIPpeakAnno::findOverlapsOfPeaks
#Use peak coverage voting to determine a final set:
Can be achieved with consensusSeekeR
Statistical model based approaches that leverage peak coverage and/or read depth information

Investigators may choose one of these strategies based on their research questions and the quality of their data.




#### FINDING OVERLAPPING Peaks 
ol <- findOverlapsOfPeaks(peaks1, peaks2)
names(ol)

## [1] "venn_cnt"           "peaklist"           "uniquePeaks"       
## [4] "mergedPeaks"        "peaksInMergedPeaks" "overlappingPeaks"  
## [7] "all.peaks"

venn_cnt	#an object of VennCounts
peaklist	#a list consists of all overlapping peaks or unique peaks
uniquePeaks	#an object of GRanges consists of all unique peaks
mergedPeaks	#an object of GRanges consists of all merged overlapping peaks
peaksInMergedPeaks	#an object of GRanges consists of all peaks in each samples involved in the overlapping peaks
overlappingPeaks	#a list of data frame consists of the annotation of all the overlapped peaks
all.peaks #a list of GRanges object which contain the input peaks with formated rownames.



##### Extracting the table of overlapp #### 
names(ol$peaklist) #Output --> 3 different GRobject
                       # "Peaks1" = peaks1 specific 
                       # "Peaks2" = peaks2 specific
                       # "Peaks1///Peaks2" = Overlaping 

GrangesObj <- ol$peaklist$`peaks1///peaks2`
rtracklayer::export(GrangesObj, "File.bed", format = "BED")





# For three samples:
data(peaks3)
ol2 <- findOverlapsOfPeaks(peaks1, peaks2, peaks3,
                           connectedPeaks = "min")


# Find peaks with at least 90% overlap = super stringent !!:
ol3 <- findOverlapsOfPeaks(peaks1, peaks2, minoverlap = 0.9)
# Keeping all peaks
ol <- findOverlapsOfPeaks(ctrl_gr, ntr_gr, connectedPeaks = "keepAll") 
connectedPeaks : define the way of counting 
                - KeepAll # count the number of peak overlaping (add 1 each time if muliple)
                - merge # Count only 1 even if multiple peaks overlap the same peak
                - min # Count only 1 time the peak
if 5 peaks in group1 overlap with 2 peaks in group 2, setting connectedPeaks to "merge" will add 1 to the overlapping counts; setting it to "keepAll" will add 5 peaks to count.group1, 2 to count.group2, and 2 to counts; setting it to “min” will add 2 to the overlapping counts.


The results are an object of overlappingPeaks.
This object provides comprehensive information about the overlappings, allowing for further visualization and interpretation:
  
- venn_cnt: an object of VennCounts, which can be used to draw a Venn diagram
- peaklist: a list of GRanges objects that contains all merged overlapping peaks or unique peaks
- uniquePeaks: an object of GRanges that consists of all unique peaks
- mergedPeaks: an object of GRanges that consists of all merged overlapping peaks
- peaksInMergedPeaks: an object of GRanges that consists of all peaks in each samples involved in the overlapping peaks
- overlappingPeaks: a list of data frames that consists of the annotation of all overlapping peaks
- all.peaks: a list of GRanges objects that consists the input peaks with formatted rownames

To determine the number of peaks that are unique to each peak set (i.e., not overlapping with any peaks in other set), you can use the following code:
  
  
  # For two samples:
  venn <- makeVennDiagram(ol, totalTest = 100,
                          fill = c("#009E73", "#F0E442"),
                          col = c("#D55E00", "#0072B2"),
                          cat.col = c("#D55E00", "#0072B2"))

